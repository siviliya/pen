### long在32位系统不是原子性

对于32位操作系统来说，单次次操作能处理的最长长度为32bit，而long类型8字节64bit，所以对long的读写都要两条指令才能完成（即每次读写64bit中的32bit）。

### cpu流水线指令

* 取指IF
* 译码和取寄存器操作数ID
* 执行或者有效地址计算EX
* 存储器访问MEM
* 写回WB

当指令完成译码时，便可进行下一条指令的取指IF操作

### java Thread类的线程状态定义

```java
public static enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;

    private State() {
    }
}
```



# ReentrantLock

ReentrantLock 可重入锁(能够连续获得同一把锁)

## 公平锁与非公平锁

公平锁能够解决饥饿现象(按队列里边的先后顺序)，需要维护一个有序队列，成本高性能相对较低。

非公平锁随机指定(synchronized就是非公平锁)。

```java
//默认使用非公平锁
public ReentrantLock() {
    this.sync = new ReentrantLock.NonfairSync();
}

public ReentrantLock(boolean fair) {
    this.sync = (ReentrantLock.Sync)(fair ? new ReentrantLock.FairSync() : new ReentrantLock.NonfairSync());
}
```

## 非公平锁加锁

（1）NonfairSync.lock()

```java
/**
 * Performs lock.  Try immediate barge, backing up to normal
 * acquire on failure.
 */
final void lock() {
    //cas的操作保证原子性，将state从0->1，成功返回true，加锁成功。
    if (compareAndSetState(0, 1))
        //设置当前抢到锁的线程
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}

```

（2）AbstractQueuedSunchronizer.acquire()

```java
//短路与，没有获取成功则加入等待队列尾部
public final void acquire(int arg) {
    if (!this.tryAcquire(arg) && this.acquireQueued(this.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), arg)) {
        selfInterrupt();
    }

}
```

（3）tryAcquire()

```java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}
```

（4）nonfairTryAcquire()

```java
/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    //获取state值
    int c = getState();
    //state=0表示当前没有线程持有锁，则使用cas尝试获取
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            //抢到了就退出
            return true;
        }
    }
    //如果state>0则表示当前锁被线程持有，则判断是不是自己持有
    else if (current == getExclusiveOwnerThread()) {
        //如果是当前线程，则重入，state+1
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

* 获取当前的state的值
* 如果state=0，表示当前没线程持有锁，则尝试获取锁（将state=0使用cas修改成1，如果成功则设置当前线程，和上面的逻辑一致）
* 如果state>0表示当前锁被线程持有，则判断持有锁的线程是不是当前线程，如果是当前线程，则state+1，这里是实现可重入锁的关键
* 否则返回false，则会将当前线程的信息生成Node节点，打入到等待队列

（5）unLock()

```java
public void unlock() {
    sync.release(1);
}
```

（6）release()

```java
protected final boolean tryRelease(int releases) {
            int c = this.getState() - releases;
            if (Thread.currentThread() != this.getExclusiveOwnerThread()) {
                throw new IllegalMonitorStateException();
            } else {
                boolean free = false;
                if (c == 0) {
                    free = true;
                    this.setExclusiveOwnerThread((Thread)null);
                }

                this.setState(c);
                return free;
            }
        }
```

* 首先将state-releases，这里如果是实现锁的情况，releases的值一般是1，这里我详细解释一下，假如线程A第一次获取锁则state=1，当线程A继续获取该锁（重入）则state+1=2，以此类推，每重入一次则加1，当释放锁的时候，则进行相应的减1，只有当全部释放完state=0时才返回true，但是如果当调用condition.await()方法则会直接将state减成0，因为要全部释放锁
* 判断当前释放锁的线程是不是持有锁的线程，如果不是则抛异常，线程A不能释放线程B持有的锁
* 当全部释放完，state=0，则将持有锁的线程变量设置成null，表示当前没有线程持有锁
* 否则返回false

## 解决死锁的方法

* **中断响应：**通过使用lockInterruptibly()加锁，使得能够响应中断
* **锁申请等待限时：**使用tryLock(number, TimeUnit.SECONDS)传入等待时间，超时返回false

## 常用的方法

* lock()：获取锁，如果锁被占用，则等待。
* lockInterruptibly()：获得锁，优先响应中断。
* tryLock()：尝试获取锁，如果成功，返回true；如果不成功过，则直接返回false(不等待)。
* tryLock(long time, TimeUnit unit)：在给定时间内尝试获取锁，超时直接返回false。
* unlock()：释放锁。

## 重入锁的实现的要素

集中在java层面

* 原子状态。通过CAS(Compare And Swap)操作存储当前锁的状态，判断锁是否被别的线程持有。
  * 通过一个int类型的state去控制锁
  * 当state=0表示当前锁没有被占有，>0表示被线程占有
  * 抢锁的过程其实就是使用cas尝试讲state=0修改成state=1，如果抢到锁，需要记录抢到锁的线程
  * 当一个线程多次获取一个锁时，是在state做累加，同时释放的话就递减
  * 释放锁就是将state=1（或者>1是递减）变成state=0，**此时不需要使用cas，因为没有竞争，锁是被当前线程持有的**，当锁完全释放，则设置当前持有锁的那个变量设置为null
* 等待队列。没有请求到锁的线程，进入等待队列等待。线程释放锁的时候，系统从等待队列唤醒一个线程工作。
  * 非公平锁是随机挑选一个进行唤醒
  * 公平锁按照有序队列先后顺序进行唤醒
* 阻塞原语。park()和upark()，用来挂起和恢复线程。没得到锁的线程就被挂起。

# Conditon条件

```java
void await() throws InterruptedException;

void awaitUninterruptibly();

long awaitNanos(long var1) throws InterruptedException;

boolean await(long var1, TimeUnit var3) throws InterruptedException;

boolean awaitUntil(Date var1) throws InterruptedException;

void signal();

void signalAll();
```

* await()使当前线程等待，同时释放当前锁。(与Object的wait()类似)

* awaitUninterruptibly()与await()相比，不会在等待时响应中断。
* singal()唤醒一个等待线程。singalAll()唤醒所有等待的线程。

# Semaphore信号量

**允许多个线程同时访问某一个资源**

```java
public Semaphore(int permits) {
    this.sync = new Semaphore.NonfairSync(permits);
}
//int permits指定信号量的准入数(同时能申请多少个许可)，boolean fair指定是否公平
public Semaphore(int permits, boolean fair) {
    this.sync = (Semaphore.Sync)(fair ? new Semaphore.FairSync(permits) : new Semaphore.NonfairSync(permits));
}
```

**主要方法**

```java
//尝试获取准入的许可，无法获得则等待，或者当前线程被中断。
public void acquire() throws InterruptedException {
    this.sync.acquireSharedInterruptibly(1);
}
//不响应中断
public void acquireUninterruptibly() {
    this.sync.acquireShared(1);
}
//尝试获得许可，失败立即返回，不等待
public boolean tryAcquire() {
    return this.sync.nonfairTryAcquireShared(1) >= 0;
}
//超时返回
public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException {
    return this.sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}
//释放许可
public void release() {
    this.sync.releaseShared(1);
}
```

# ReadWriteLock

## 为什么要使用读写分离锁

能够减少锁竞争，

