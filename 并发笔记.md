### long在32位系统不是原子性

对于32位操作系统来说，单次次操作能处理的最长长度为32bit，而long类型8字节64bit，所以对long的读写都要两条指令才能完成（即每次读写64bit中的32bit）。

### cpu流水线指令

* 取指IF
* 译码和取寄存器操作数ID
* 执行或者有效地址计算EX
* 存储器访问MEM
* 写回WB

当指令完成译码时，便可进行下一条指令的取指IF操作

### java Thread类的线程状态定义

```java
public static enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;

    private State() {
    }
}
```



# ReentrantLock

ReentrantLock 可重入锁(能够连续获得同一把锁)

## 公平锁与非公平锁

公平锁能够解决饥饿现象(按队列里边的先后顺序)，需要维护一个有序队列，成本高性能相对较低。

非公平锁随机指定(synchronized就是非公平锁)。

```java
//默认使用非公平锁
public ReentrantLock() {
    this.sync = new ReentrantLock.NonfairSync();
}

public ReentrantLock(boolean fair) {
    this.sync = (ReentrantLock.Sync)(fair ? new ReentrantLock.FairSync() : new ReentrantLock.NonfairSync());
}
```

## 非公平锁加锁

（1）NonfairSync.lock()

```java
/**
 * Performs lock.  Try immediate barge, backing up to normal
 * acquire on failure.
 */
final void lock() {
    //cas的操作保证原子性，将state从0->1，成功返回true，加锁成功。
    if (compareAndSetState(0, 1))
        //设置当前抢到锁的线程
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}

```

（2）AbstractQueuedSunchronizer.acquire()

```java
//短路与，没有获取成功则加入等待队列尾部
public final void acquire(int arg) {
    if (!this.tryAcquire(arg) && this.acquireQueued(this.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), arg)) {
        selfInterrupt();
    }

}
```

（3）tryAcquire()

```java
protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}
```

（4）nonfairTryAcquire()

```java
/**
 * Performs non-fair tryLock.  tryAcquire is implemented in
 * subclasses, but both need nonfair try for trylock method.
 */
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    //获取state值
    int c = getState();
    //state=0表示当前没有线程持有锁，则使用cas尝试获取
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            //抢到了就退出
            return true;
        }
    }
    //如果state>0则表示当前锁被线程持有，则判断是不是自己持有
    else if (current == getExclusiveOwnerThread()) {
        //如果是当前线程，则重入，state+1
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

* 获取当前的state的值
* 如果state=0，表示当前没线程持有锁，则尝试获取锁（将state=0使用cas修改成1，如果成功则设置当前线程，和上面的逻辑一致）
* 如果state>0表示当前锁被线程持有，则判断持有锁的线程是不是当前线程，如果是当前线程，则state+1，这里是实现可重入锁的关键
* 否则返回false，则会将当前线程的信息生成Node节点，打入到等待队列

（5）unLock()

```java
public void unlock() {
    sync.release(1);
}
```

（6）release()

```java
protected final boolean tryRelease(int releases) {
            int c = this.getState() - releases;
            if (Thread.currentThread() != this.getExclusiveOwnerThread()) {
                throw new IllegalMonitorStateException();
            } else {
                boolean free = false;
                if (c == 0) {
                    free = true;
                    this.setExclusiveOwnerThread((Thread)null);
                }

                this.setState(c);
                return free;
            }
        }
```

* 首先将state-releases，这里如果是实现锁的情况，releases的值一般是1，这里我详细解释一下，假如线程A第一次获取锁则state=1，当线程A继续获取该锁（重入）则state+1=2，以此类推，每重入一次则加1，当释放锁的时候，则进行相应的减1，只有当全部释放完state=0时才返回true，但是如果当调用condition.await()方法则会直接将state减成0，因为要全部释放锁
* 判断当前释放锁的线程是不是持有锁的线程，如果不是则抛异常，线程A不能释放线程B持有的锁
* 当全部释放完，state=0，则将持有锁的线程变量设置成null，表示当前没有线程持有锁
* 否则返回false

## 解决死锁的方法

* **中断响应：**通过使用lockInterruptibly()加锁，使得能够响应中断
* **锁申请等待限时：**使用tryLock(number, TimeUnit.SECONDS)传入等待时间，超时返回false

## 常用的方法

* lock()：获取锁，如果锁被占用，则等待。
* lockInterruptibly()：获得锁，优先响应中断。
* tryLock()：尝试获取锁，如果成功，返回true；如果不成功过，则直接返回false(不等待)。
* tryLock(long time, TimeUnit unit)：在给定时间内尝试获取锁，超时直接返回false。
* unlock()：释放锁。

## 重入锁的实现的要素

集中在java层面

* 原子状态。通过CAS(Compare And Swap)操作存储当前锁的状态，判断锁是否被别的线程持有。
  * 通过一个int类型的state去控制锁
  * 当state=0表示当前锁没有被占有，>0表示被线程占有
  * 抢锁的过程其实就是使用cas尝试讲state=0修改成state=1，如果抢到锁，需要记录抢到锁的线程
  * 当一个线程多次获取一个锁时，是在state做累加，同时释放的话就递减
  * 释放锁就是将state=1（或者>1是递减）变成state=0，**此时不需要使用cas，因为没有竞争，锁是被当前线程持有的**，当锁完全释放，则设置当前持有锁的那个变量设置为null
* 等待队列。没有请求到锁的线程，进入等待队列等待。线程释放锁的时候，系统从等待队列唤醒一个线程工作。
  * 非公平锁是随机挑选一个进行唤醒
  * 公平锁按照有序队列先后顺序进行唤醒
* 阻塞原语。park()和upark()，用来挂起和恢复线程。没得到锁的线程就被挂起。

# Conditon条件

```java
void await() throws InterruptedException;

void awaitUninterruptibly();

long awaitNanos(long var1) throws InterruptedException;

boolean await(long var1, TimeUnit var3) throws InterruptedException;

boolean awaitUntil(Date var1) throws InterruptedException;

void signal();

void signalAll();
```

* await()使当前线程等待，同时释放当前锁。(与Object的wait()类似)

* awaitUninterruptibly()与await()相比，不会在等待时响应中断。
* singal()唤醒一个等待线程。singalAll()唤醒所有等待的线程。

# Semaphore信号量

**允许多个线程同时访问某一个资源**

```java
public Semaphore(int permits) {
    this.sync = new Semaphore.NonfairSync(permits);
}
//int permits指定信号量的准入数(同时能申请多少个许可)，boolean fair指定是否公平
public Semaphore(int permits, boolean fair) {
    this.sync = (Semaphore.Sync)(fair ? new Semaphore.FairSync(permits) : new Semaphore.NonfairSync(permits));
}
```

**主要方法**

```java
//尝试获取准入的许可，无法获得则等待，或者当前线程被中断。
public void acquire() throws InterruptedException {
    this.sync.acquireSharedInterruptibly(1);
}
//不响应中断
public void acquireUninterruptibly() {
    this.sync.acquireShared(1);
}
//尝试获得许可，失败立即返回，不等待
public boolean tryAcquire() {
    return this.sync.nonfairTryAcquireShared(1) >= 0;
}
//超时返回
public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException {
    return this.sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}
//释放许可
public void release() {
    this.sync.releaseShared(1);
}
```

# ReadWriteLock

## 为什么要使用读写分离锁

能够减少锁竞争，A1,A2,A3写操作，B1,B2,B3读操作。B1读，则B2B3等待。

读写锁允许多个线程读。实现B1,B2,B3并行。

## 约束规则

* 读-读不互斥，不阻塞
* 读-写互斥，读阻塞写，写阻塞读
* 写-写互斥，写写阻塞

# CountDownLatch倒计时器

```java
//count为传入的线程数
public CountDownLatch(int count) {
    if (count < 0) {
        throw new IllegalArgumentException("count < 0");
    } else {
        this.sync = new CountDownLatch.Sync(count);
    }
}
//每有一个线程完成任务时，
public void countDown() {
    this.sync.releaseShared(1);
}

//调用await阻塞 等待count为0(即线程完成数为10)才继续往下走
public void await() throws InterruptedException {
    this.sync.acquireSharedInterruptibly(1);
}

```

# CyclicBarrier循环栅栏

与CountDownLatch相比，计数器能够重复使用，第一批10个线程完成后，开始下一批线程的计时器倒数。

并且可以接收一个Runnable barrierAction参数，在计时器完成一次计时后执行

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    this.lock = new ReentrantLock();
    this.trip = this.lock.newCondition();
    this.generation = new CyclicBarrier.Generation();
    if (parties <= 0) {
        throw new IllegalArgumentException();
    } else {
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }
}

public CyclicBarrier(int parties) {
    this(parties, (Runnable)null);
}
```

一次计数完成后再调用public int await()会开启下一个计数

```java
//InterruptedException线程被中断的常见异常
//BrokenBarrierException表示当前的CyclicBarrier已破损(好比其中一个线程被中断)，避免其它线程进行永久无所谓的等待。
public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return this.dowait(false, 0L);
    } catch (TimeoutException var2) {
        throw new Error(var2);
    }
}

public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException {
    return this.dowait(true, unit.toNanos(timeout));
}
```

# LockSupport线程阻塞工具类

* 能够在线程内任意地方让线程阻塞
* 与Thread.suspend()**(阻塞线程，但是不会放弃锁)**，弥补了先调用resume()造成的死锁问题
* 与Object.wait()相比，不用去获取某一个对象的锁，不会抛出InterruptedException异常
* 即使先调用unpark()也不会造成死锁
  * 使用了类似信号量的机制，为每一个线程准备了一个许可
    * 许可可用，立即返回，消费该许可(许可变为不可用)
    * 许可不可用，阻塞
  * unpark()使一个许可从不可用变为可用状态(一个线程在LockSupport中只能有一个许可)
  * park()不会抛出InterruptedException异常

```java
public static void unpark(Thread thread) {
    if (thread != null) {
        U.unpark(thread);
    }

}

public static void park() {
    U.park(false, 0L);
}
//为当前线程设置阻塞对象
public static void park(Object blocker) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker);
    U.park(false, 0L);
    setBlocker(t, (Object)null);
}

public static void parkNanos(Object blocker, long nanos) {
    if (nanos > 0L) {
        Thread t = Thread.currentThread();
        setBlocker(t, blocker);
        U.park(false, nanos);
        setBlocker(t, (Object)null);
    }

}

public static void parkUntil(Object blocker, long deadline) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker);
    U.park(true, deadline);
    setBlocker(t, (Object)null);
}
```

# 线程池

## 为什么要使用线程池

* 传统方法下创建线程，当线程运行完run()方法后就回收，当创建的线程量过大，反而会影响cpu和内存资源‘
* 创建和关闭都需要花费时间，如果每次都为一个小任务创建线程，可能会出现创建与关闭线程的时间大于线程工作的时间
* 大量线程可能会抢占线程资源，造成OutOfMemory异常。或是大量的线程回收会给GC回收带来很大的压力，延长GC的停顿时间

## 什么是线程池

* 避免频繁的创建和销毁线程，对创建的线程池进行复用。

* 创建线程->从线程池获得空闲线程
* 关闭线程->将线程归还给线程池
