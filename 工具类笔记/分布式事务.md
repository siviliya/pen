# 事务的概念

由一个有限的数据库操作序列构成，这些操作需要满足四个特性，即**原子性、一致性、隔离性、持久性**，简称ACID。

# mysql XA分布式事务

## 概念



![](..\images\分布式事务-1.jpg)

* **AP：**是指应用程序。
* **RM：**是资源管理器，事务的参与者，通常是数据库，比如MySQL Server。一个分布式事务通常涉及多个资源管理器。
* **TM：**是事务管理器，创建分布式事务并协调分布式事务中的各个子事务的执行和状态。子事务是指分布式事务中在RM上执行的具体操作。
* **两阶段提交： (**Two-Phase Commit, 简称2PC**) ,**是为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。分布式事务通常采用2PC，二阶段提交的算法思路可以概括为： 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作，这里的参与者可以理解为RM，协调者可以理解为TM。

## XA相关语句

* **XA START xid:** 开启一个事务，并将事务置于ACTIVE状态，此后执行的SQL语句都将置于该是事务中。
* **XA END xid:** 将事务置于IDLE状态，表示事务内的SQL操作完成。
* **XA PREPARE xid:** 实现事务提交的准备工作，事务状态置于PREPARED状态。事务如果无法完成提交前的准备操作，该语句会执行失败。
* **XA COMMIT xid:** 事务最终提交，完成持久化。
* **XA ROLLBACK xid:** 事务回滚终止。
* **XA RECOVER:** 查看MySQL中存在的PREPARED状态的xa事务。

## 两阶段提交

![分布式事务-2](..\images\分布式事务-2.PNG)

* **阶段一为准备（prepare）阶段。**即所有的RM锁住需要的资源，在本地执行这个事务（执行sql，写redo/undo log等），但不提交，然后向Transaction Manager报告已准备就绪。
* **阶段二为提交阶段（commit）。**当Transaction Manager确认所有参与者都ready后，向所有参与者发送commit命令。如果任何一个RM在**一阶段**中返回不能提交，则涉及分布式事务的所有RM都被告知需要回滚。

![分布式事务-3](..\images\分布式事务-3.jpg)

### 出现的问题

* **分布式死锁问题：**MySQL Server 是可以检测和解决单个MySQL实例中的死锁问题，但涉及到跨越多个MySQL 实例的分布式事务时候，需要程序层面实现死锁的检测和解决。
* **分布式读一致性问题：**MySQL的read view 也是实例级别的，对于全局分布式事务来说无法实现读一致，只能通过select ... lock in share mode在读请求上加锁的串行化隔离级别来实现，这必然会带来并发性能的下降。这就需要在程序层面构建全局的read view来实现全局的MVCC 。
* **性能问题：**一个数据库的事务和多个数据库间的XA事务性能对比可发现，性能差10倍左右。另外，XA过程中会长时间的占用资源（加锁）直到两阶段提交完成才释放资源。

# seata实现分布式事务

## 概念

![分布式事务-4](..\images\分布式事务-4.png)

* **Transaction Coordinator (TC)： 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。**
* **Transaction Manager (TM)： 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。**
* **Resource Manager (RM)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。**

## 第一阶段就提交了分支事务



## seata执行流程

* **TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID**
* **XID 在微服务调用链路的上下文中传播。**
* **RM 向 TC 注册分支事务，接着执行这个分支事务并提交（重点：RM在第一阶段就已经执行了本地事务的提交/回滚），最后将执行结果汇报给TC。**
  * 在全局事务ID下注册分支事务ID
* **RM 开始执行这个分支事务，RM首先解析这条SQL语句，生成对应的UNDO_LOG记录。**
* RM在同一个本地事务中执行业务SQL和UNDO_LOG数据的插入。在提交这个本地事务前，RM会向TC申请关于这条记录的全局锁。如果申请不到，则说明有其他事务也在对这条记录进行操作，因此它会在一段时间内重试，重试失败则回滚本地事务，并向TC汇报本地事务执行失败。

![分布式事务-5](..\images\分布式事务-5.webp)

* RM在事务提交前，申请到了相关记录的全局锁，因此直接提交本地事务，并向TC汇报本地事务执行成功。此时全局锁并没有释放，全局锁的释放取决于二阶段是提交命令还是回滚命令。

* TC根据所有的分支事务执行结果，向RM下发提交或回滚命令。

* RM如果收到TC的提交命令，首先立即释放相关记录的全局锁，然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。

* TC根据所有的分支事务执行结果，向RM下发提交或回滚命令。

  * **RM收到TC的提交命令：**首先立即释放相关记录的全局锁，然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。

  ![分布式事务-7](..\images\分布式事务-7.webp)

  * **RM收到TC的回滚命令：**开启一个本地事务，通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。将 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。否则，根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句并执行，然后提交本地事务达到回滚的目的，最后释放相关记录的全局锁。

  ![分布式事务-8](..\images\分布式事务-8.webp)

## seata隔离级别

Seata由于一阶段RM自动提交本地事务的原因，默认隔离级别为Read Uncommitted。如果希望隔离级别为Read Committed，那么可以使用`SELECT...FOR UPDATE`语句。Seata引擎重写了`SELECT...FOR UPDATE`语句执行逻辑，`SELECT...FOR UPDATE` 语句的执行会申请 全局锁 ，如果 全局锁 被其他事务持有，则释放本地锁（回滚 `SELECT...FOR UPDATE` 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 全局锁 拿到，即读取的相关数据是已提交的才返回。



## Seata支持的模式

### AT

依赖于RM拥有本地数据库事务的能力，对于客户业务无侵入性。

![分布式事务-9](..\images\分布式事务-9.webp)

### MT

MT模式本质上是一种TCC方案，业务逻辑需要被拆分为 Prepare/Commit/Rollback 3 部分，形成一个 MT 分支，加入全局事务。MT 模式一方面是 AT 模式的补充。另外，更重要的价值在于，通过 MT 模式可以把众多非事务性资源纳入全局事务的管理中。

![分布式事务-10](..\images\分布式事务-10.webp)

